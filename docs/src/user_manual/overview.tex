\chapter{Compiler Overview}

The compilation toolchain contains five major components:

\begin{itemize}
\item\textbf{Compiler} (\tx{legno.py} and \tx{legno_runner.py}): The compiler.
  It reads dynamical system programs (in the \tx{prog} directory) and generates
  grendel scripts. These scripts can be executed by the runtime.  
\item\textbf{Runtime} (\tx{grendel.py}): The runtime. It executes grendel
  scripts on the analog device by dispatching commands to the microcontroller.
\item\textbf{Firmware} (\tx{lab_bench} directory): The firmware. This must be
  written to the microcontroller in order for the microcontroller to understand
  the grendel commands.
\item\textbf{Experiment Driver} (\tx{exp_driver.py}): This tool analyzes the outputs
  produced by the analog chip. It computes the energy, power, quality (with
  respect to a reference simulation) and runtime of each program.
\item\textbf{Model Builder} (\tx{model_builder.py}): This tool builds delta
  models from empirical data collected from analog blocks using grendel
  commands. These models are used by the \legno compiler during the \lscale and
  \srcgen pass to compensate for behavioral deviations in the device. 
\end{itemize}


\section{\legno Compiler}

The \legno compiler (\tx{legno.py}) enables developers to compile dynamical
systems down to configurations for the analog hardware. The \legno compiler
requires that dynamical systems be specified in the \tx{dynamical system
  language}, a high level language that supports writing first-order
differential equations. The \legno compiler also accepts a specification of the
target analog device, described using the Analog Device API. The \legno compiler
generates an \textit{analog device program} (\tx{adp}) which implements the target dynamical
system on the specified analog device. The compiler is broken up into three
passes:

\begin{itemize}
  \item\lgraph: This pass synthesizes an unscaled circuit that implements the
    specified dynamical system.
  \item\lscale : This pass synthesizes one or more scaled circuits for each
    unscaled circuit generated by the \lgraph pass.
  \item\srcgen: This pass generates a \tx{.grendel} script for each
    scaled circuit generated by the \lscale path. The \tx{.grendel} script
    configures the analog device and optionally the oscilloscope, and executes
    the simulation described in the dynamical system program.
  \end{itemize}

The \legno compiler accepts a \tx{--subset} argument which indicates what subset of
device features to use to compile the program. There are three subsets supported
by the compiler:

\begin{itemize}
\item\tx{standard} subset: This limits the accepted modes of each block to the
  medium mode (-2 uA to 2 uA). 
\item\tx{extended} subset: This limits the accepted modes of each block to the
  high (-20 uA to 20 uA) and medium (-2 uA to 2 uA) modes.
\item\tx{unrestricted} subset: This allows all modes (low, medium and high) to
  be used. This subset involves modes that have not been thoroughly tested by us.
\end{itemize}

The \legno compiler writes all compilation outputs for some program
\tx{<prog>} compiled with the feature subset \tx{<subset>} to the following
directory:

\begin{snippet}
  outputs/legno/<subset>/<program>/
\end{snippet}

This directory has eight subdirectories:

\begin{itemize}
\item\tx{lgraph-adp} and \tx{lgraph-diag}: These directories contain the
  unscaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lgraph} pass of the \legno compiler (Section \ref{sec:lgraph}).
\item\tx{lscale-adp} and \tx{lscale-diag}: These directories contain the
  scaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lscale} pass of the \legno compiler (Section \ref{sec:lscale}), and are derived from
  files in the \tx{lgraph-adp} directory.
\item \tx{grendel}: This directory contains the compiled \tx{.grendel} scripts
  generated by the \srcgen pass of the \legno compiler, and are derived from
  scaled circuits produced by the \tx{lscale} pass.
\item\tx{times}: this directory contains the runtime information for each
  compilation pass.
\item\tx{sim}: this directory contains digital simulation results for the
  program. These results are generated by the \tx{simulate} operation of the
  \legno compiler (see Section \ref{sec:dslang})
\item\tx{out-waveform} (oscilloscope): this directory contains the output waveforms
    collected by the oscilloscope during execution. This directory is populated by the
    \grendel runtime.
\item\tx{plots} (oscilloscope): this directory contains visualizations of the output
  waveforms collected by the oscilloscope. These plots are generated by the
  experiment driver (\tx{exp_driver.py}).
\end{itemize}

\section{Runtime System}

The \grendel runtime dispatches \tx{.grendel} scripts to the analog device. The
\grendel scripting language supports configuring the analog device, running
experiments and setting up the Sigilent 1020XE oscilloscope. It collects and writes the
oscilloscope data to the following directory (given a <program> compiled with
the <subset> feature set)

\begin{snippet}
  outputs/legno/<subset>/<program>/out-waveform
\end{snippet}

The grendel runtime communicates with a microcontroller running the \grendel
firmware. This firmware is found in the following directory:

\begin{snippet}
  legno-compiler/lab_bench/arduino/grendel_interp_V1
\end{snippet}

\subsection{Calibration and Profiling}

The \grendel runtime system is able to calibrate and profile blocks that appear
in a \grendel script. The system caches combinations of calibration codes and
profiling information in the \textit{state database} (\tx{state.db}), which
resides at the following location:

\begin{snippet}
  legno-compiler/device-state/state.db
\end{snippet}


\noindent\textbf{Calibration}: The \grendel runtime is able to calibrate blocks to
minimize some objective function. The code values selected by the calibration
routine are cached in the state database. The runtime and firmware currently supports
two objective functions:

\begin{itemize}
\item\tx{min_error}: This objective function minimizes the error of the output across a
  sequence of test inputs.
\item\tx{max_fit}: This objective function minimizes the delta model error
  (maximizes the fit of the delta model) across a sequence of test inputs. 
\end{itemize}

\noindent\textbf{Profiling}: The \grendel runtime is able to profile calibrated blocks.
The profiling operation tests the block with 100-200 inputs and records the
bias (error) and noise of the measured output. This profiling information is
used to build a model that describes the behavior of the block.

\section{Experiment Driver}

The experiment driver (\tx{exp_driver.py}) performs batch execution and analysis
on the analog computer. It requires the Sigilent oscilloscope be used. The
experiment driver has three functions:

\begin{itemize}
\item\textbf{Mass Execution}: The run routine executes any outstanding
\tx{grendel} scripts (grendel scripts that don't have outputs) on the analog
device.

\item\textbf{Analysis}: The analysis routine applies the transform computed by the
compiler to the measured waveform to recover the original dynamics. It then
compares the recovered waveform with the expected dynamics (computed via digital
simulation). The analyzer also computes the wall-clock time and power required to
execute the simulation. 

\item\textbf{Visualization}: The visualize routine is able to emit a variety of
statistical summaries for benchmarks. All tables and figures are written to the
\tx{PAPER} directory. 
\end{itemize}

\section{Model Inference}

The model inference engine (\tx{model_builder.py}) converts the profiling data
collected by the grendel runtime into a symbolic delta model that the \legno compiler
can use. It infers delta models from all of the profiling data from the state database
(\tx{state.db}). The delta models are written to the model database
(\tx{model.db}). The model database is stored in the following location:

\begin{snippet}
  legno-compiler/device-state/model.db
\end{snippet}

The model inference engine optionally emits visualizations and text descriptions
of the models, which can be found in the location below:

\begin{snippet}
  legno-compiler/device-state/models
\end{snippet}

The models in the database are used by \lscale and \srcgen to correct for
deviations in block behavior at compile time.