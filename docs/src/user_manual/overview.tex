\chapter{Compiler Overview}

The compilation toolchain contains five major components:

\begin{itemize}
\item\textbf{Compiler} (\tx{legno.py}): The compiler. It reads dynamical system
  programs (in the \tx{prog} directory) and generates analog device programs.
  These programs can be executed by the runtime. The \tx{legno.py} script also
  offers several convenience functions (which wrap the runtime) for running,
  simulating, and visualizing ADPs and characterizing the device. 
  
\item\textbf{Runtime} (\tx{grendel.py} and \tx{meta_grendel.py}): The runtime.
  It executes ADPs on the analog device by dispatching commands to the
  microcontroller. The core runtime (\tx{grendel.py}) also offers calibration,
  profiling, and model elicitation subcommands which calibrate and characterize
  the board and build empirical models which capture the behavior of the board.
  These empirical models are used in the \tx{lscale} pass of the compiler.
  The meta-runtime (\tx{meta_grendel.py}) uses the core runtime to test the
  board, identify and characterize poorly performing blocks.
  
\item\textbf{Firmware} (\tx{lab_bench} directory): The firmware. The bare-metal
  grendel interpreter (\tx{lab_bench/arduino/grendel_interp_v2}) must be
  written to the microcontroller in order for the microcontroller to understand
  the grendel commands. The \tx{lab_bench} directory also contains some
  host-side libraries for interacting with the microcontroller.
 
\end{itemize}


\section{\legno Compiler}

The \legno compiler (\tx{legno.py}) enables developers to compile dynamical
systems down to configurations for the analog hardware. The \legno compiler
requires that dynamical systems be specified in the \tx{dynamical system
  language}, a high level language that supports writing first-order
differential equations. The \legno compiler also accepts a specification of the
target analog device, described using the Analog Device API. The \legno compiler
generates an \textit{analog device program} (\tx{adp}) which implements the target dynamical
system on the specified analog device. The compiler is broken up into three
passes:

\begin{itemize}
  \item\lgraph: This pass synthesizes an unscaled circuit that implements the
    specified dynamical system.
  \item\lscale : This pass synthesizes one or more scaled circuits for each
    unscaled circuit generated by the \lgraph pass.
  \end{itemize}


The \legno compiler works with the \tx{unrestricted} subset of block features. This
limits the accepted modes of each block to the high (-20 uA to 20 uA) and medium
(-2 uA to 2 uA) modes. These are the modes which have been most thoroughly
tested by us. Note that the \hcdc also offers low modes (\tx{0.2}) --
these are untested and therefore unsupported by the compiler.

The \legno compiler writes all compilation outputs for some program
\tx{<prog>} compiled with the feature subset \tx{<subset>} to the following
directory:

\begin{snippet}
  outputs/legno/<subset>/<program>/
\end{snippet}

This directory has eight subdirectories:

\begin{itemize}
\item\tx{lgraph-adp} and \tx{lgraph-diag}: These directories contain the
  unscaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lgraph} pass of the \legno compiler (Section \ref{sec:lgraph}).
\item\tx{lscale-adp} and \tx{lscale-diag}: These directories contain the
  scaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lscale} pass of the \legno compiler (Section \ref{sec:lscale}), and are derived from
  files in the \tx{lgraph-adp} directory.
\item\tx{times}: this directory contains the runtime information for each
  compilation pass.
\item\tx{sim}: this directory contains digital simulation results for the
  program. These results are generated by the \tx{simulate} operation of the
  \legno compiler (see Section \ref{sec:dslang})
\item\tx{out-waveform}: this directory contains the output waveforms
  collected from the \hcdc during execution. This directory is populated by
  the grendel runtime (\tx{grendel.py}) or by the legno compiler's \tx{lexec}
  subroutine which invokes the grendel runtime.
  
\item\tx{plots}: this directory contains visualizations of the output
  waveforms collected by the \hcdc chip. These plots are generated by legno's
  waveform analysis (\tx{lwav}) command and re are written to the \tx{plots/wav}
  subdirectory. This directory may also contain software simulation plots. The
  software simulation plots are generated by legnos simulation (\tx{lsim})
  command.
  
\end{itemize}

\section{Runtime System}

The \grendel runtime executes analog device programs and calibrates and
characterizes the board. It maintains all of the calibration information,
profiling data, and empirically derived models (which capture the manufacutring
variations) in the \textit{device state database}. The device state database is
located at the following location:

\begin{snippet}
  device-state/hcdcv2/<model-number>/hcdcv2-<model-number>.db
\end{snippet}

This database maintains two important tables -- the delta model table and the
profiling data table. The delta model table stores empirically derived symbolic
models for each calibration strategy and the calibration information for each
calibration strategy. The profiling data table maintains the datasets which
capture the behavior of each calibrated block. The firmware and grendel runtime
offer several calibration strategies which inform how the block is calibrated:

\begin{itemize}
\item \textbf{Maximize Fit} (\tx{minimize_error},\tx{minerr}): This calibration strategy allows for analog blocks
  to have variations in the gain they introduce. It optimizes for eliminating
  any constant offsets (biases) and eliminating any hard-to-characterize behavior (point
  errors). This calibration strategy is executed on the device firmware using a
  heuristic search.

\item\textbf{Minimize Error} (\tx{maximize_fit},\tx{maxfit}): This calibration strategy calibrates analog
  blocks to deliver behavior that closely follows the behavior in the hardware
  specification. This calibration strategy is executed on the device firmware
  using a heuristic search.

\item\textbf{Bruteforce} (\tx{bruteforce},\tx{brute}): This calibration strategy randomly samples the
      space of calibration codes and chooses the best one. This strategy is
      performed on the host-side and is usually reserved for blocks which
      perform poorly when calibrated with the previous two strategy.

\item\textbf{Best} (\tx{best}): This calibration strategy chooses the best performing block
      calibration strategy.
    
\end{itemize}

\noindent~We will walk through the various operations which can be performed
with the \grendel runtime in this section.

\noindent\textbf{Advice on device state database}: The device state database
should be backed up regularly as it caches a great deal of calibration and
profiling information which is time-intensive to recompute. Note that this
database is not irreplaceable -- it can easily be repopulated if it is lost with
a few commands. We may periodically ask for end-users to submit their device state database as it
provides valuable information on how the board is functioning and can help.

\subsection{ADP Execution}

The primary function of the \grendel runtime is to execute analog device
programs. The \grendel runtime dispatches scaled \tx{.adps} to the analog device and
writes any collected waveforms to the following directory:

\begin{snippet}
  outputs/legno/<subset>/<program>/out-waveform/wav
\end{snippet}

\noindent~The grendel runtime communicates with a microcontroller running the \grendel
firmware. This firmware is found in the following directory:

\begin{snippet}
  legno-compiler/lab_bench/arduino/grendel_interp_V1
\end{snippet}

\subsection{Calibrating Blocks in an ADP}

Calibration is the first step to deriving the empirical models for each block.
The grendel runtime supports invoking the on-board firmware calibration routines
for the blocks in a target analog device program. Only the 
\tx{maximize_Fit}/\tx{minimize_error} calibration strategies may be selected as
they are implemented directed in the firmware. Refer to Sections~\ref{XXX} or
Sections~\ref{XXX} for information on how to do the bruteforce or best-performing
calibration strategies. The following invocation calibrates all the blocks in
the file \tx{<file>.adp} using the \tx{maximize_fit} strategy and writes the
calibration information to the board's device state database: 

\begin{snippet}
  python3 grendel.py cal --model-number <model-number> <file>.adp maximize_fit
\end{snippet}

The calibration routine takes a long time to complete because it calibrates the
block under each possible block configuration. All this information is written to the
\tx{hcdc-<model_number>.db} database -- if this procedure is interrupted, it will
pick up from where it left off. 


\subsection{Profiling Blocks in an ADP}

Calibrated blocks can be profiled with the \grendel runtime's \tx{prof}
subcommand. It accepts as input the analog device program which contains the
blocks to profile and the calibration strategy which was used. It looks up the
calibration information in the state database and exercises the
block over the input space to collect a set of input-output pairs which describe
the behavior of the calibrated block. We write an example invocation below:

\begin{snippet}
 python3 grendel.py prof --model-number <model-number> <file>.adp maximize_fit
 --grid-size 17
\end{snippet}

The \tx{--grid-size} argument tells the profiler how many points to break each
input into. For example, if a block takes inputs \tx{x} and \tx{y}, the profiler
will break up the input space for each input into 17 points. It will therefore
try $17^2$ test points to evaluate the behavior of the block being tested. The
profiler skips over any calibrated blocks which have already been profiled to
save time.

This routine also accepts other optional arguments, which we describe below:

\begin{itemize}
\item\textbf{\tx{--min-points} argument}: This argument tells the runtime how
  many input-output pairs need to be in the dataset for the dataset to be
  complete. This argument is used to determine if a block has already been
  profiled.
  \item\textbf{\tx{--force} argument}: This argument forces the profiler to
    re-profile every block in the analog device program. This can be useful if
    the profiling information is somehow incomplete or malformed.
   \item\textbf{\tx{--missing} argument}: This argument tells the profiler to
     ignore the analog device program and instead calibrate any blocks in the
     database which are missing profiling data.
\end{itemize}


\subsection{Inferring Delta Models from the Profiling Data}

The \grendel runtime uses the profiling data to construct empirically-derived
symbolic models which describe the behavior of each block instance in practice
in each programming mode. The model inference algorithm is executed with the
following command:

\begin{snippet}
python3 grendel.py mkdeltas --model-number <model-number>
\end{snippet}

This command fits the profiling data in the state database to the delta model
specification from the hardware specification. It updates the delta models in
the database to include the fitted models. The \tx{mkdeltas} subcommand skips
over any already computed delta models -- it can be made to recompute all delta
models with the \tx{--force} command. The \tx{mkdeltas} subcommand can also be
forced to skip over any profiling datasets which don't have enough points with
the \tx{--min-points} argument. 

\subsection{Calibrating, Profiling, and Modelling Blocks with \tx{lcal}}

The \legno compiler offers a convenience command for performing calibration,
profiling, and delta model elicitation in one step. Simply run the following
command to calibrate, profile, and infer models for all ADPs which
implement a particular program \tx{<prog>}:

\begin{snippet}
python3 legno.py lcal <prog> --model-number <model_number>
\end{snippet}

The above command will calibrate and profile all blocks in the ADPs with both
the \tx{minimize_error} and \tx{maximize_fit} calibration strategies.

\subsection{Visualizing Block Behavior}

The \grendel runtime offers a command for visualizing the errors associated with
the profiled blocks. The following command populates the
\tx{device-state/hcdcv2/<model-number>/viz} directory with heatmaps detailing
the percent error of each block over the input space:

\begin{snippet}
python3 grendel.py vis --model-number <model-number> --histogram <calibrate_objective>
\end{snippet}

Because the visualization operation is time consuming, it requires the end user
specify which calibration objective
(\tx{minimize_error},\tx{maximize_fit},\tx{best},\tx{brute}) to investigate. The
\tx{--histogram} argument tells the visualization algorithm to render histograms
showing the distribution of errors across blocks. 

\subsection{Characterizing Badly Behaving Blocks and Bruteforce Calibration}

Some blocks are badly behaved -- we often want to take a closer look at these
blocks to better understand why they are failing and potentially get a better
calibration setting for them. The grendel runtime offers a
convenience function for identifying and characterizing these blocks:



\subsection{Selecting the Best Calibration Strategy}

\subsection{Full-Board Testing}

