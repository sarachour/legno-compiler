\chapter{Compiler Overview}

The compilation toolchain contains five major components:

\begin{itemize}
\item\textbf{Compiler} (\tx{legno.py}): The compiler. It reads dynamical system
  programs (in the \tx{prog} directory) and generates analog device programs.
  These programs can be executed by the runtime. The \tx{legno.py} script also
  offers several convenience functions (which wrap the runtime) for running,
  simulating, and visualizing ADPs and characterizing the device. 
  
\item\textbf{Runtime} (\tx{grendel.py} and \tx{meta_grendel.py}): The runtime.
  It executes ADPs on the analog device by dispatching commands to the
  microcontroller. The core runtime (\tx{grendel.py}) also offers calibration,
  profiling, and model elicitation subcommands which calibrate and characterize
  the board and build empirical models which capture the behavior of the board.
  These empirical models are used in the \tx{lscale} pass of the compiler.
  The meta-runtime (\tx{meta_grendel.py}) uses the core runtime to test the
  board, identify and characterize poorly performing blocks.
  
\item\textbf{Firmware} (\tx{lab_bench} directory): The firmware. The bare-metal
  grendel interpreter (\tx{lab_bench/arduino/grendel_interp_v2}) must be
  written to the microcontroller in order for the microcontroller to understand
  the grendel commands. The \tx{lab_bench} directory also contains some
  host-side libraries for interacting with the microcontroller.
 
\end{itemize}


\section{\legno Compiler}

The \legno compiler (\tx{legno.py}) enables developers to compile dynamical
systems down to configurations for the analog hardware. The \legno compiler
requires that dynamical systems be specified in the \tx{dynamical system
  language}, a high level language that supports writing first-order
differential equations. The \legno compiler also accepts a specification of the
target analog device, described using the Analog Device API. The \legno compiler
generates an \textit{analog device program} (\tx{adp}) which implements the target dynamical
system on the specified analog device. The compiler is broken up into three
passes:

\begin{itemize}
  \item\lgraph: This pass synthesizes an unscaled circuit that implements the
    specified dynamical system.
  \item\lscale : This pass synthesizes one or more scaled circuits for each
    unscaled circuit generated by the \lgraph pass.
  \end{itemize}


The \legno compiler works with the \tx{unrestricted} subset of block features. This
limits the accepted modes of each block to the high (-20 uA to 20 uA) and medium
(-2 uA to 2 uA) modes. These are the modes which have been most thoroughly
tested by us. Note that the \hcdc also offers low modes (\tx{0.2}) --
these are untested and therefore unsupported by the compiler.

The \legno compiler writes all compilation outputs for some program
\tx{<prog>} compiled with the feature subset \tx{<subset>} to the following
directory:

\begin{snippet}
  outputs/legno/<subset>/<program>/
\end{snippet}

This directory has eight subdirectories:

\begin{itemize}
\item\tx{lgraph-adp} and \tx{lgraph-diag}: These directories contain the
  unscaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lgraph} pass of the \legno compiler (Section \ref{sec:lgraph}).
\item\tx{lscale-adp} and \tx{lscale-diag}: These directories contain the
  scaled analog device programs and associated diagrams. The diagrams are visual
  representations of the programs that are useful for debugging. These files are
  produced by the \tx{lscale} pass of the \legno compiler (Section \ref{sec:lscale}), and are derived from
  files in the \tx{lgraph-adp} directory.
\item\tx{times}: this directory contains the runtime information for each
  compilation pass.
\item\tx{sim}: this directory contains digital simulation results for the
  program. These results are generated by the \tx{simulate} operation of the
  \legno compiler (see Section \ref{sec:dslang})
\item\tx{out-waveform}: this directory contains the output waveforms
  collected from the \hcdc during execution. This directory is populated by
  the grendel runtime (\tx{grendel.py}) or by the legno compiler's \tx{lexec}
  subroutine which invokes the grendel runtime.
  
\item\tx{plots}: this directory contains visualizations of the output
  waveforms collected by the \hcdc chip. These plots are generated by legno's
  waveform analysis (\tx{lwav}) command and re are written to the \tx{plots/wav}
  subdirectory. This directory may also contain software simulation plots. The
  software simulation plots are generated by legnos simulation (\tx{lsim})
  command.
  
\end{itemize}

\section{Runtime System}

The \grendel runtime executes analog device programs and calibrates and
characterizes the board. It maintains all of the calibration information,
profiling data, and empirically derived models (which capture the manufacutring
variations) in the \textit{device state database}. The device state database is
located at the following location:

\begin{snippet}
  device-state/hcdcv2/<model-number>/hcdcv2-<model-number>.db
\end{snippet}

This database maintains two key tables -- the delta model table and the
profiling data table. The delta model table stores empirically derived symbolic
models for each calibration strategy.

XXXXXXX STOPPED HERE XXXXXXX

\subsection{ADP Execution}

The primary function of the \grendel runtime is to execute analog device
programs. The \grendel runtime dispatches scaled \tx{.adps} to the analog device and
writes any collected waveforms to the following directory:

\begin{snippet}
  outputs/legno/<subset>/<program>/out-waveform/wav
\end{snippet}

\noindent~The grendel runtime communicates with a microcontroller running the \grendel
firmware. This firmware is found in the following directory:

\begin{snippet}
  legno-compiler/lab_bench/arduino/grendel_interp_V1
\end{snippet}


\subsection{Board Calibration and Characterization}

The \grendel runtime system supports calibrating and profiles blocks

that appear
in a \grendel script. The system caches combinations of calibration codes and
profiling information in the \textit{state database} (\tx{state.db}), which
resides at the following location:

\begin{snippet}
  legno-compiler/device-state/state.db
\end{snippet}


\noindent\textbf{Calibration}: The \grendel runtime is able to calibrate blocks to
minimize some objective function. The code values selected by the calibration
routine are cached in the state database. The runtime and firmware currently supports
two objective functions:

\begin{itemize}
\item\tx{min_error}: This objective function minimizes the error of the output across a
  sequence of test inputs.
\item\tx{max_fit}: This objective function minimizes the delta model error
  (maximizes the fit of the delta model) across a sequence of test inputs. 
\end{itemize}

\noindent\textbf{Profiling}: The \grendel runtime is able to profile calibrated blocks.
The profiling operation tests the block with 100-200 inputs and records the
bias (error) and noise of the measured output. This profiling information is
used to build a model that describes the behavior of the block.

\section{Experiment Driver}

The experiment driver (\tx{exp_driver.py}) performs batch execution and analysis
on the analog computer. It requires the Sigilent oscilloscope be used. The
experiment driver has three functions:

\begin{itemize}
\item\textbf{Mass Execution}: The run routine executes any outstanding
\tx{grendel} scripts (grendel scripts that don't have outputs) on the analog
device.

\item\textbf{Analysis}: The analysis routine applies the transform computed by the
compiler to the measured waveform to recover the original dynamics. It then
compares the recovered waveform with the expected dynamics (computed via digital
simulation). The analyzer also computes the wall-clock time and power required to
execute the simulation. 

\item\textbf{Visualization}: The visualize routine is able to emit a variety of
statistical summaries for benchmarks. All tables and figures are written to the
\tx{PAPER} directory. 
\end{itemize}

\section{Model Inference}

The model inference engine (\tx{model_builder.py}) converts the profiling data
collected by the grendel runtime into a symbolic delta model that the \legno compiler
can use. It infers delta models from all of the profiling data from the state database
(\tx{state.db}). The delta models are written to the model database
(\tx{model.db}). The model database is stored in the following location:

\begin{snippet}
  legno-compiler/device-state/model.db
\end{snippet}

The model inference engine optionally emits visualizations and text descriptions
of the models, which can be found in the location below:

\begin{snippet}
  legno-compiler/device-state/models
\end{snippet}

The models in the database are used by \lscale and \srcgen to correct for
deviations in block behavior at compile time.