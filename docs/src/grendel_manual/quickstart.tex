\chapter{Grendel Quickstart}

The \grendel runtime system (\tx{grendel.py}) enables developers to dispatch
commands to the \hcdc analog device on the fly. The \grendel runtime is used to
execute scripts generated by the \legno compiler as well as calibrate and profile
blocks on the device. 

\subsection{Installation}

The \grendel runtime is a pure python program. To install the python
dependencies, execute the following command:

\begin{snippet}
  pip install -r packages.list
\end{snippet}



Both the \legno compiler and the \grendel runtime work with a \tx{config.py}
file that specifies the relevant output directories and database files. To use
the default configuration, execute the following copy command:

\begin{snippet}
cp util/config_local.py util/config.py
\end{snippet}


To write the device firmward to the SA100ASY development board, you must install the Arduino
IDE. To install the Arduino IDE, follow the following link:

\begin{snippet}
https://www.arduino.cc/en/Main/Software
\end{snippet}

After installing the Arduino IDE, navigate to \tx{Tools/Board} in the menu, and select the \tx{Board Manager}
option. After doing so, search for \tx{Due} and install the \tx{Arduino Sam Boards (32 bits ARM-Cortex M3} package.
We installed 1.6.12.

You also want to install the \tx{DueTimer} package. This can be done by navigating to the 
\tx{Sketch/Include Library/Manage Libraries} option in the Arduino IDE and searching for the \tx{DueTimer} package.
We installed 1.4.7.

We use a Makefile to build the firmware. The Makefile makes use of the \tx{android-mk} package. To install 
\tx{android-mk}, execute the following commands if you're on linux:

\begin{snippet}
sudo apt-get install arduino-mk
\end{snippet}

Or the following commands if you're on OSX:
\begin{snippet}
brew tap sudar/arduino-mk
brew install --HEAD arduino-mk

After following these steps, it should be possible to flash the HCDCv2 firmware to the analog device. Navigate
to the following directory:
\begin{snippet}
lab_bench/arduino/grendel_interp_V1
\end{snippet}

To build the firmware, type `make`. This should complete without incident. After the make command completes 
successfully type `make upload` to flash the firmware to the device. Please ensure the device is programmed via USB,
and that the USB cable is plugged into the programming port of the device. This is the port closest to the DC power port. 

If you get an error along the lines of `import failed, serial not found`, this is likely because \tx{arduino-mk} is using 
a different version of python than the rest of the project. To mitigate this, install pyserial for \tx{python2}:

\begin{snippet}
pip install pyserial
\end{snippet}

\subsection{Anatomy of a Grendel Script}

The following section of the quickstart guide breaks down the 
\tx{test/cosfun.grendel} script. The \tx{cosfun}
script configures the analog device to emit a
cosine function at output 0 of the analog device (the \tx{A0} and \tx{A1}
differential pair). This differential pair is connected to a Sigilent 1202X-E
oscilloscope, which we use to record waveforms~\ref{sigilent.py}.

We describe the anatomy of the \grendel script below. Generally, commands
prefixed \tx{micro_} are sent to the microcontroller and commands prefixed with
\tx{osc_} are sent to the oscilloscope. Any commands lacking these prefixes are
dispatched to the analog device through the microcontroller.


Each \grendel script begins with a preamble that sets the parameters for the
experiment. The \tx{cosfun} script configures the microcontroller to use the
analog chip to execute the simulation (\tx{micro_use_chip}) and produce a
trigger signal to tell the oscilloscope to start recording (\tx{micro_use_osc}). The \tx{micro_reset}
command resets the parameters of the experiment that are stored on the
microcontroller.

\begin{snippet}
micro_reset
micro_use_chip
micro_use_osc
micro_set_sim_time 1.587e-03
\end{snippet}

The \grendel script then configures the time and voltage scales of the
oscilloscope so that the waveform fits in the viewport. The \tx{set_volt_range}
commands set the minimum and maximum voltages for channels 0 and 1 of the
oscilloscope. The \tx{osc_sim_time} command sets the amount of time the
oscilloscope should record for.

\begin{snippet}
osc_set_volt_range 0 0.102000 1.310000
osc_set_sim_time 2.063e-03
osc_set_volt_range 1 0.102000 1.310000
osc_set_sim_time 2.063e-03
\end{snippet}

The \grendel script then programs the analog device to implement the cosine
function. The cosine function is implemented as a second-order differential
equation and consists of two integrators and one current copier (\tx{fanout}
block). The integrators correspond to the position and velocity of the cosine
function, and the fanout is used to produce a copy of the position for
measurement. Figure~\ref{XXX} presents a schematic of the configured circuit.

\begin{snippet}
use_fanout 0 3 0 0  sgn + - + rng m two
use_integ 0 3 0 sgn + val 0.8359375 rng h m debug
use_integ 0 3 1 sgn + val 0.0 rng h m debug
mkconn fanout 0 3 0 0 port 0 tile_output 0 3 0 0
mkconn tile_output 0 3 0 0 chip_output 0 3 2
mkconn integ 0 3 0 fanout 0 3 0 0
mkconn integ 0 3 1 integ 0 3 0
mkconn fanout 0 3 0 0 port 1 integ 0 3 1
\end{snippet}

With the analog device configured, the \grendel script configures the
oscilloscope to listen for a trigger (\tx{osc_setup_trigger}), then executes
the simulation (\tx{micro_run}). The waveform is retrieved from the oscilloscope using the
\tx{osc_get_values} command. This command returns the differential signal
between channel 0 and channel 1 of the oscilloscope (\tx{CH0}-\tx{CH1}). The
measured signal corresponds to the position (\tx{Pos}) of the cosine function,
and is written to the \tx{waveform.json} file when it's done. The \grendel
script also reports the exception status for the integrators that were used by
the simulation. 

\begin{snippet}
osc_setup_trigger
micro_run
osc_get_values differential 0 1 Pos waveform.json
get_integ_status 0 3 0
get_integ_status 0 3 1
micro_get_status
\end{snippet}

After the simulation has finished executing, the \grendel script tears down the
analog device configuration. It disables any enabled blocks and unsets and
programmed connections.

\begin{snippet}
disable fanout 0 3 0 0
disable integ 0 3 0
disable integ 0 3 1
rmconn fanout 0 3 0 0 port 0 tile_output 0 3 0 0
rmconn tile_output 0 3 0 0 chip_output 0 3 2
rmconn integ 0 3 0 fanout 0 3 0 0
rmconn integ 0 3 1 integ 0 3 0
rmconn fanout 0 3 0 0 port 1 integ 0 3 1
\end{snippet}

\section{Executing the Grendel Script}

Before the \tx{cosfun.grendel} script can be executed, any uncalibrated blocks
must be \textit{calibrated}. When a block is configured by the grendel script
through a \tx{use_} statement, only some of the parameters are set. We call the
parameters that are set through a \grendel command \textit{visible} codes. The
parameters that are not set through a \grendel command are \textit{hidden}
or \textit{calibration} codes. These codes are computed by the calibration
procedure and cached in the state database (\tx{state.db}). For each set of
visible code values, the block must be calibrated. We calibrate all the
partially configured blocks that appear in the \tx{cosfun} script with the
following command:


\begin{snippet}
python3 grendel.py --calib-obj min_error calibrate test/cosfun.grendel
\end{snippet}

This command tells the \grendel runtime to calibrate the integrator and current
copier blocks in the script. The \tx{--calib-obj} tells the \grendel runtime the
metric the calibration routine should minimize when looking for the best set of
calibration codes. The \tx{min_error} objective function returns the error
between the expected and observed behavior for a set of test points.

After the calibration procedure is done, we can then use the grendel runtime to
execute the script. This command runs the simulation on the analog device, and
writes the measured waveform to \tx{waveform.json}:

\begin{snippet}
python3 grendel.py --calib-obj min_error run test/cosfun.grendel
\end{snippet}

The \tx{--calib-obj} flag specifies which set of calibration codes to use to finish
configuring the block. We tell the \grendel runtime to use the calibration codes
that were computed with the \tx{min_error} objective function.

\section{Analyzing the Results}

We can view the waveform using the following python code snippet:

\begin{pysnippet}
  import scripts.analysis.quality as qualitylib
  import matplotlib.pyplot as plt
  times,values = qualitylib.read_meas_data('waveform.json')
  plt.plot(times,values)
  plt.savefig('waveform.png')
\end{pysnippet}

The \tx{read_meas_data} script decompresses and parses the \tx{json} file. Once
this file is parsed, the data can then be plotted. Figure~\ref{ex:waveform} presents the
simulation produced by the analog device. Note that there is not information in
the \grendel script to recover the original simulation. Refer to the section on
\expdriver for instructions on how to do that.
