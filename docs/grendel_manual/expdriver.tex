\chapter{Batch Execution with Experiment Driver}

\expdriver is a batch processing tool that automatically finds an executes all \grendel scripts in
the \tx{output} directory. \expdriver is designed to work with \grendel
scripts generated by the \legno compiler, and uses the \grendel runtime as a
subroutine for many of its operations. It therefore relies on the naming
conventions and directory structure used by the \legno compiler.

In addition to batch executing scripts, \expdriver is able to analyze and
produce visualizations for the waveforms generated by the executions. \expdriver
post-processes the collected signals using the scaling factors produced by the
\legno compiler and compares the recovered signal to a ground-truth reference
signal. The \expdriver is also able to compute the runtime and energy
requirements for each execution.

The \expdriver tracks the state of each experiment in a database located in
\tx{outputs/experiment.db}.

\subsection{Scanning for \grendel Scripts}

We use \expdriver to scan for \grendel scripts using the following command:

\begin{lstlisting}
  python3 exp_driver.py scan
\end{lstlisting}

This command automatically searches for any \grendel scripts in the \tx{outputs}
directory and adds them to the experiment database~\cite{experiment.db}. The
experiment database tracks the execution and analysis results of each
experiment. All scripts start out as \tx{pending} or \tx{ran}. A script is
marked as \tx{ran} if all of the waveforms it is supposed to generate are present.


\subsection{Executing Pending Grendel Scripts}
Next we tell \expdriver to execute any pending experiments.

\begin{lstlisting}
  python3 exp_driver run --calibrate
\end{lstlisting}

The \tx{--calibrate} flag tells \expdriver to calibrate any
blocks that require calibration before running the experiments. Note that the
\tx{--calib-obj} flag is automatically inferred from the model used to compile
the script. If the program was scaled by \lscale using a \tx{naive} model, the
\tx{min_error} calibration objective is used for calibration and execution. If the program was
scaled by \lscale using a \tx{partial} or \tx{physical} model, the \tx{max_delta}
calibration objective is used for calibration and execution.

\subsection{Analyzing Grendel Scripts}

Assume we have a grendel script for some program \tx{bmark} that was generated
with the \legno compiler that resides at the following path:
\begin{snippet}
outputs/legno/{subset}/{bmark}/grendel/{bmark}_{legno_id}_{tag}_{obj}_{menv}_{hwenv}.grendel
\end{snippet}

\expdriver supports analyzing the waveforms produced by \grendel scripts provided the following criteria are met:

\begin{itemize}
\item The\tx{bmark} dynamical system program the \grendel script implements exists in the
  \tx{bmarks} directory and can be found by the \tx{legno} compiler.
  \item The experiment has been executed. More concretely, the waveform files
    (\tx{.json}) in the \grendel script exist in the
    \tx{outputs/legno/{subset}/{bmark}/out_waveforms} directory.
  \item There is an analog device program for the \grendel script. This program 
    must exist at the following location:
    \begin{snippet}
      output/legno/{subset}/{bmark}/conc-circ/{bmark}_{lgraph_id}_s{lscale_id}_{tag}_{obj}.circ
    \end{snippet}
    
    \expdriver uses the corresponding analog device program for the \grendel
    script to scale the waveform. Note that the scaling transform computed from
    the analog device program is produced by the compiler and not derived by
    using a reference signal in any way.
  \end{itemize}

  Provided the above criteria are met, the analysis routine analyzes 
 the waveforms for each experiment. All of these analysis results
  are stored in the experiment database (\tx{experiments.db}). Once all the
  waveforms in an experiment have been analyzed, the experiment status is
  changed to \tx{analyzed}. We present a summary of the analysis results below:

  \begin{itemize}
   \item\textit{Runtime}: Using the time scaling factor computed by
     the \legno compiler, \expdriver reports the runtime of the simulation in
     wall clock time~\cite{params.py}. This quantity is the same across all waveforms.
  \item\textit{Energy}: Using the energy model for the
    hardware and the runtime of the simulation (in hardware time), \expdriver
    estimates how many $\mu J$ are required to execute the
    simulation~\cite{energy_model.py,energy.py}. This quantity is the same
    across all waveforms.
  \item\textit{Quality Measurements}: Using the time and amplitude scaling
    factors computed by the \legno compiler, \expdriver converts the times and
    values of the measured waveform to simulation times and values. The signal
    is then aligned in the time domain with a reference signal, which is computed using a
    high-precision digital solver. This alignment procedure only allows time
    shifting to account for synchronization issues between unleashing the
    capacitors and triggering the oscilloscope. After aligning the signals
    \expdriver computes a the sum squared errors between the reference and
    observed signals~\cite{quality.py,params.py}. This is the quality metric for
    the execution (lower is better).
   
\end{itemize}

\expdriver produces several helpful plots while
computing the quality of the waveform. These plots are written to the
\tx{output/legno/{subset}/{bmark}/plots} directory. Each visualization is tagged
with a suffix that indicates what kind of plot it is. We present a summary of
the suffixes below:

\begin{itemize}
  \item\tx{_ref.png}: The reference simulation. The time is in simulation units and
  the value is in state variable units.
  \item\tx{_meas.png}: The waveform measured from the oscilloscope. The time is in
  wall clock time units, and the amplitude is in volts. 
  \item\tx{_pred.png}: The waveform that is expected to be generated by the chip.
  This is computed by applying the time and amplitude scaling factors from the
  analog device program to the reference waveform. The time is in wall block
  time units and the amplitude is in volts.
  \item\tx{_rec.png}: The measured waveform, after the extraneous parts of the signal have
  been trimmed away and the scaling transform has been un-applied. The time is in
  simulation time units, and the amplitude is in state variable units. We call
  this the recovered waveform.
  \item\tx{_comp.png}: A comparison between the recovered waveform and the reference
  waveform. This discrepency between these signals informs the quality of the simulation. 
\end{itemize}

\subsection{The Scaling Transform}

In this section, we go into a bit more detail on how the scaling transform is
used to recover the desired simulation from the measured signal. The scaling
transform is computed from the analog device program that produced the grendel
script:
\begin{snippet}
  output/legno/{subset}/{bmark}/conc-circ/{bmark}_{legno_id}_{tag}_{obj}.circ
\end{snippet}

This program was generated by the \lscale pass of the \legno compiler. This
means that the parameters in the program have already been scaled so the signals
fit within the operating constraints of the device. \expdriver reads the
following quantities from the program~\cite{params.py}:
\begin{itemize}
\item\textbf{Time Scaling Factor}: \expdriver reads the time scaling factor
  $\tau$ from the program.
\item\textbf{Waveform Scaling Factor}: For each waveform, \expdriver finds the
  port in the analog device program that emitted the waveform. The scaling
  factor at this port, $\alpha$, is the scaling factor for the waveform.

\end{itemize}

\expdriver uses the $\tau$ and $\alpha$ parameters to predict the measured
waveform from the reference waveform and recover the original dynamics of the
signal from the measured waveform. We describe these procedures below:

\subsubsection{Recovery of Original Signal}

Given a waveform collected from a
measurement device, such as an oscilloscope, \expdriver recovers the original
dynamics of the signal by applying the following transforms to the time ($t_{meas}$)
and voltage $v_{meas}$ measurements:
\begin{align}
t_{rec} &= (t_{meas} - \delta) \cdot \tau^{-1} & v_{rec} &= v_{meas} \cdot \alpha^{-1} \\
\end{align}
In this equation, $\delta$ is the time shift found by the alignment procedure.
Refer to the \tx{scale_obs_data} function in the \tx{quality.py} file for the
implementation. Note that the implementation also trims away any measurements
that occur before or after the simulation.


\subsubsection{Predicting Measurements from Reference Signal}
Given a
reference signal computed by digitally executing the dynamical system, the
time and waveform scaling factors can be used to predict the measured signal.
This is done by applying the following transform to the simulation time
($t_{ref}$) and amplitude $v_{ref}$measurements:
\begin{align}
t_{pred} &= t_{ref} \cdot \tau & v_{pred} &= v_{ref} \cdot \alpha \\
\end{align}

Refer to the \tx{scale_ref_data} function in the \tx{quality.py} file for the
implementation.

\subsubsection{Aligning Signals}

\expdriver aligns signals by taking the
cross correlation of the resampled signals, and finding the offset that has the
highest correlation value. This offset is then converted into a time delay
$\delta$. The time delay is the lag of the measured signal with respect to the
reference signal. 